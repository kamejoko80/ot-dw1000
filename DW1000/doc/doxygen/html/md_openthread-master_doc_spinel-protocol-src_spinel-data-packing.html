<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OT-DW1000: Data Packing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Open-Thread-Logo-200x42.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OT-DW1000
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Data Packing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Data serialization for properties is performed using a light-weight data packing format which was loosely inspired by D-Bus. The format of a serialization is defined by a specially formatted string.</p>
<p>This packing format is used for notational convenience. While this string-based datatype format has been designed so that the strings may be directly used by a structured data parser, such a thing is not required to implement Spinel. Indeed, higly constrained applications may find such a thing to be too heavyweight.</p>
<p>Goals:</p>
<ul>
<li>Be lightweight and favor direct representation of values.</li>
<li>Use an easily readable and memorable format string.</li>
<li>Support lists and structures.</li>
<li>Allow properties to be appended to structures while maintaining backward compatibility.</li>
</ul>
<p>Each primitive datatype has an ASCII character associated with it. Structures can be represented as strings of these characters. For example:</p>
<ul>
<li><code>C</code>: A single unsigned byte.</li>
<li><code>C6U</code>: A single unsigned byte, followed by a 128-bit IPv6 address, followed by a zero-terminated UTF8 string.</li>
<li><code>A(6)</code>: An array of concatenated IPv6 addresses</li>
</ul>
<p>In each case, the data is represented exactly as described. For example, an array of 10 IPv6 address is stored as 160 bytes.</p>
<h2>Primitive Types</h2>
<table class="doxtable">
<tr>
<th>Char </th><th align="left">Name </th><th align="left">Description  </th></tr>
<tr>
<td><code>.</code> </td><td align="left">DATATYPE_VOID </td><td align="left">Empty data type. Used internally. </td></tr>
<tr>
<td><code>b</code> </td><td align="left">DATATYPE_BOOL </td><td align="left">Boolean value. Encoded in 8-bits as either 0x00 or 0x01. All other values are illegal. </td></tr>
<tr>
<td><code>C</code> </td><td align="left">DATATYPE_UINT8 </td><td align="left">Unsigned 8-bit integer. </td></tr>
<tr>
<td><code>c</code> </td><td align="left">DATATYPE_INT8 </td><td align="left">Signed 8-bit integer. </td></tr>
<tr>
<td><code>S</code> </td><td align="left">DATATYPE_UINT16 </td><td align="left">Unsigned 16-bit integer. </td></tr>
<tr>
<td><code>s</code> </td><td align="left">DATATYPE_INT16 </td><td align="left">Signed 16-bit integer. </td></tr>
<tr>
<td><code>L</code> </td><td align="left">DATATYPE_UINT32 </td><td align="left">Unsigned 32-bit integer. </td></tr>
<tr>
<td><code>l</code> </td><td align="left">DATATYPE_INT32 </td><td align="left">Signed 32-bit integer. </td></tr>
<tr>
<td><code>i</code> </td><td align="left">DATATYPE_UINT_PACKED </td><td align="left">Packed Unsigned Integer. See (#packed-unsigned-integer). </td></tr>
<tr>
<td><code>6</code> </td><td align="left">DATATYPE_IPv6ADDR </td><td align="left">IPv6 Address. (Big-endian) </td></tr>
<tr>
<td><code>E</code> </td><td align="left">DATATYPE_EUI64 </td><td align="left">EUI-64 Address. (Big-endian) </td></tr>
<tr>
<td><code>e</code> </td><td align="left">DATATYPE_EUI48 </td><td align="left">EUI-48 Address. (Big-endian) </td></tr>
<tr>
<td><code>D</code> </td><td align="left">DATATYPE_DATA </td><td align="left">Arbitrary data. See (#data-blobs). </td></tr>
<tr>
<td><code>d</code> </td><td align="left">DATATYPE_DATA_WLEN </td><td align="left">Arbitrary data with prepended length. See (#data-blobs). </td></tr>
<tr>
<td><code>U</code> </td><td align="left">DATATYPE_UTF8 </td><td align="left">Zero-terminated UTF8-encoded string. </td></tr>
<tr>
<td><code>t(...)</code> </td><td align="left">DATATYPE_STRUCT </td><td align="left">Structured datatype with prepended length. See (#structured-data). </td></tr>
<tr>
<td><code>A(...)</code> </td><td align="left">DATATYPE_ARRAY </td><td align="left">Array of datatypes. Compound type. See (#arrays). </td></tr>
</table>
<p>All multi-byte values are little-endian unless explicitly stated otherwise.</p>
<h2>Packed Unsigned Integer</h2>
<p>For certain types of integers, such command or property identifiers, usually have a value on the wire that is less than 127. However, in order to not preclude the use of values larger than 255, we would need to add an extra byte. Doing this would add an extra byte to the majority of instances, which can add up in terms of bandwidth.</p>
<p>The packed unsigned integer format is based on the <a href="https://www.w3.org/TR/exi/#encodingUnsignedInteger">unsigned integer format in EXI</a>, except that we limit the maximum value to the largest value that can be encoded into three bytes(2,097,151).</p>
<p>For all values less than 127, the packed form of the number is simply a single byte which directly represents the number. For values larger than 127, the following process is used to encode the value:</p>
<ol type="1">
<li>The unsigned integer is broken up into <em>n</em> 7-bit chunks and placed into <em>n</em> octets, leaving the most significant bit of each octet unused.</li>
<li>Order the octets from least-significant to most-significant. (Little-endian)</li>
<li>Clear the most significant bit of the most significant octet. Set the least significant bit on all other octets.</li>
</ol>
<p>Where <em>n</em> is the smallest number of 7-bit chunks you can use to represent the given value.</p>
<p>Take the value 1337, for example: </p><pre class="fragment">1337 =&gt; 0x0539
     =&gt; [39 0A]
     =&gt; [B9 0A]
</pre><p>To decode the value, you collect the 7-bit chunks until you find an octet with the most significant bit clear.</p>
<h2>Data Blobs</h2>
<p>There are two types for data blobs: <code>d</code> and <code>D</code>.</p>
<ul>
<li><code>d</code> has the length of the data (in bytes) prepended to the data (with the length encoded as type <code>S</code>). The size of the length field is not included in the length.</li>
<li><code>D</code> does not have a prepended length: the length of the data is implied by the bytes remaining to be parsed. It is an error for <code>D</code> to not be the last type in a type in a type signature.</li>
</ul>
<p>This dichotomy allows for more efficient encoding by eliminating redundency. If the rest of the buffer is a data blob, encoding the length would be redundant because we already know how many bytes are in the rest of the buffer.</p>
<p>In some cases we use <code>d</code> even if it is the last field in a type signature. We do this to allow for us to be able to append additional fields to the type signature if necessary in the future. This is usually the case with embedded structs, like in the scan results.</p>
<p>For example, let's say we have a buffer that is encoded with the datatype signature of <code>CLLD</code>. In this case, it is pretty easy to tell where the start and end of the data blob is: the start is 9 bytes from the start of the buffer, and its length is the length of the buffer minus 9. (9 is the number of bytes taken up by a byte and two longs)</p>
<p>The datatype signature <code>CLLDU</code> is illegal because we can't determine where the last field (a zero-terminated UTF8 string) starts. But the datatype <code>CLLdU</code> <em>is</em> legal, because the parser can determine the exact length of the data blob&ndash; allowing it to know where the start of the next field would be.</p>
<h2>Structured Data</h2>
<p>The structure data type (<code>t(...)</code>) is a way of bundling together several fields into a single structure. It can be thought of as a <code>d</code> type except that instead of being opaque, the fields in the content are known. This is useful for things like scan results where you have substructures which are defined by different layers.</p>
<p>For example, consider the type signature <code>Lt(ES)t(6C)</code>. In this hypothetical case, the first struct is defined by the MAC layer, and the second struct is defined by the PHY layer. Because of the use of structures, we know exactly what part comes from that layer. Additionally, we can add fields to each structure without introducing backward compatability problems: Data encoded as <code>Lt(ESU)t(6C)</code> (Notice the extra <code>U</code>) will decode just fine as <code>Lt(ES)t(6C)</code>. Additionally, if we don't care about the MAC layer and only care about the network layer, we could parse as <code>Lt()t(6C)</code>.</p>
<p>Note that data encoded as <code>Lt(ES)t(6C)</code> will also parse as <code>Ldd</code>, with the structures from both layers now being opaque data blobs.</p>
<h2>Arrays</h2>
<p>An array is simply a concatenated set of <em>n</em> data encodings. For example, the type <code>A(6)</code> is simply a list of IPv6 addresses&mdash;one after the other. The type <code>A(6E)</code> likewise a concatenation of IPv6-address/EUI-64 pairs.</p>
<p>If an array contains many fields, the fields will often be surrounded by a structure (<code>t(...)</code>). This effectively prepends each item in the array with its length. This is useful for improving parsing performance or to allow additional fields to be added in the future in a backward compatible way. If there is a high certainty that additional fields will never be added, the struct may be omitted (saving two bytes per item).</p>
<p>This specification does not define a way to embed an array as a field alongside other fields. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 21 2017 18:58:05 for OT-DW1000 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
