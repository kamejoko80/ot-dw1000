<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>nRF 802.15.4 radio driver.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Open-Thread-Logo-200x42.png"/></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">CLI and NCP Application</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">nRF 802.15.4 radio driver. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This driver implements only <b>non-beacon mode</b> of operation. It supports following <b>features</b>:</p><ul>
<li>reception of unicast and broadcast frames (with filtering),</li>
<li>automatic sending ACK frames,</li>
<li>setting pending bit in ACK frame according to pending data for given destination,</li>
<li>transmission of unicast and broadcast frames,</li>
<li>automatic CCA procedure before transmission,</li>
<li>automatic receiving ACK frames,</li>
<li>low power mode (sleep),</li>
<li>energy detection,</li>
<li>promiscuous mode.</li>
</ul>
<h2>Implementation details</h2>
<p>The driver is a FSM. From API perspective it has 4 states. Most of those states contains sub-states in implementation.</p>
<h3>FSM description</h3>
<div class="fragment"><div class="line">         receive()       transmit()</div><div class="line">         --------&gt;       --------&gt;</div><div class="line">    Sleep         Receive         Transmit</div><div class="line">         &lt;-------- |  /|&lt;--------</div><div class="line">          sleep()  |   |   receive() / transmitted() / busy_channel()</div><div class="line">                   |   |</div><div class="line">energy_detection() |   | energy_detected()</div><div class="line">                  \|/  |</div><div class="line">              Energy detection</div></div><!-- fragment --><h4>Transitions</h4>
<p>The driver is initialized in the Sleep state. The higher layer should call the receive() function to make the driver enter the Receive state and start radio operations.</p>
<p>In basic applications radio should be most time in a Receive state. In this state the radio receives incoming frames. Changing to any other state should be performed from Receive state.</p>
<p>When a frame is received in Receive state the driver notifies the higher layer by calling received() function. This function is called after reception of a broadcast frame or after sending an ACK to a unicast frame. In the promiscuous mode the higher layer is notified about all of the received frames. Even if the frame was not destined to the receiving node.</p>
<p>To transmit a frame the higher layer should call the transmit() function. If channel is busy the driver goes back to the Receive state and notifies the higher layer by calling the busy_channel() function. If a broadcast frame was transmitted the driver goes back to the Receive state and notifies the higher layer by calling the transmitted() function. If a unicast frame was transmitted and an ACK was received the driver goes back to the Receive state and notifies the higher layer by calling the transmitted() function. If a unicast frame was transmitted and there was no expected ACK received the higher layer shall call the receive() function after the ACK timeout to make the driver go back to the Receive state.</p>
<p>To perform an Energy Detection procedure the higher layer should call the energy_detection() function. When the procedure is completed the driver goes automatically back to the Receive state and notifies the higher layer with the energy_detected() function.</p>
<h4>States</h4>
<h5>Sleep</h5>
<p>In this state the radio is in low power mode. It cannot transmit or receive any frame.</p>
<h5>Receive</h5>
<p>In this state the radio receives 802.15.4 frames. It filters out frames with invalid CRC, length, type, destination address. If the driver receives unicast frame destined to the receiving node it automatically transmits an ACK frame. According to 802.15.4 standard, an ACK frame should be delayed aTurnaroundTime (192 uS) after reception of the ACKed frame. To perform this delay the driver uses the TIFS timer in the radio peripheral. This timer requires 3 shorts to work correctly:</p><ol type="1">
<li>END -&gt; DISABLE</li>
<li>DISABLE -&gt; TXEN</li>
<li>READY -&gt; START The driver has limited time after receiving of a frame to decide if an ACK should be transmitted. If ACK should not be transmitted the driver must abort sending ACK by disabling those shorts and triggering DISABLE task. To use this limited time most effective the driver uses the Bit Counter feature of the radio peripheral to get notification when the Frame Control field is received and when the destination address is received. Those fields are used to filter the frame before whole frame is received. If all 3 shorts used to send ACK automatically are enabled the radio peripheral sends ACK frames in loop. To prevent this during debugging process there are only 2 shorts enabled when waiting for frame (1. and 2.) and 2 other shorts are enabled in DISABLED event handler (1. and 3.). The first short is still enabled to automatically disable transmitter after transmission of the ACK frame.</li>
</ol>
<h5>Transmit</h5>
<p>In this state the radio performs the CCA procedure. If channel is free the radio transmits requested frame. If an ACK was requested in the transmitted frame the driver automatically receives the ACK frame in this state. To prevent the TXIDLE peripheral state the driver uses 2 shorts in Transmit state:</p><ol type="1">
<li>READY -&gt; START</li>
<li>END -&gt; DISABLE Those shorts automatically start transmission of the frame when transmitter is ready and disable transmitter when the frame was transmitted.</li>
</ol>
<h5>Energy detection</h5>
<p>In this state the radio performs the Energy Detection procedure. During this procedure the radio is busy and cannot change state to any other. The end of this procedure is notified to the higher layer by a function call.</p>
<h3>Mutex and critical sections.</h3>
<p>State transitions in the FSM can be requested simultaneously by the higher layer and the IRQ handler. To prevent race conditions in the driver there is a mutex. The mutex is unlocked only in the <em>Receive</em> state (<em>WaitingRxFrame</em> substate). If there is requested state transition, the procedure shall lock the mutex before state is changed. If mutex cannot be locked, another procedure has locked it and is going to change the state. The mutex is unlocked when the driver enters <em>Receive</em> state.</p>
<p>A race condition could also occur during handle of a requests from the higher layer. Even if the receiver is stopped (TASK STOP) the END or DISABLED event can be raised for a few uS after triggering the task. To prevent interrupt of the higher layer request handler by IRQ handler, the higher layer request handlers are performend in critical sections. The critical sections are implemented as software interrupt requests with priority equal to the RADIO IRQ. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 15 2017 18:32:35 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
